= Trunk CI playbook
:page-tags: diataxis:reference, domain:platform, audience:contrib, stability:beta
:reviewed: 2025-11-11

This workspace keeps Trunk for developer ergonomics, but we lean on system
runtimes and ci caching rather than hermetic downloads.

[NOTE]
====
The repository no longer ships a top-level `.trunk/` directory. Canonical
configuration lives under `n00-cortex/data/trunk/base/.trunk/` and inside the
individual subrepositories. Copy or overlay those configs onto runners (via
`scripts/sync-trunk-defs.mjs` or repo-specific automation) before invoking the
CLI, and export `TRUNK_BIN` because there is no repo-local launcher anymore.

Workspace automation no longer auto installs the Trunk CLI on developer
machines. Run `trunk upgrade --no-progress` (or
`TRUNK_INSTALL=1 .dev/automation/scripts/trunk-upgrade.sh`) when you explicitly
want the binary locally. CI/ephemeral runners should set `TRUNK_INSTALL=1` so
they can self-bootstrap without polluting personal caches.
====

== Sourcing configuration

. Update `n00-cortex/data/trunk/base/.trunk/trunk.yaml` when policy changes are
	required.
. Run `scripts/sync-trunk-defs.mjs` (or
	`.dev/automation/scripts/run-trunk-subrepos.sh --sync-only`) so subrepos pick
	up the refreshed definitions.
. Ensure CI prepares a writable cache (for example `~/.cache/trunk`) and copies
	the canonical config into each repo that depends on Trunk.
. Set `TRUNK_BIN` or add the Trunk binary to `PATH` on every runner because the
	workspace no longer vendors the launcher.

== Runtimes

Trunk configuration (`n00-frontiers/.trunk/trunk.yaml`) allows the system
Node.js, Python, and Go installs. Make sure your ci image already includes the
versions declared in `n00-cortex/data/toolchain-manifest.json`.

[,yaml]
----
runtimes: enabled:
 - python
 - go
 - node
definitions:
 - type: python
system_version: allowed
 - type: go
system_version: allowed
 - type: node
 system_version: allowed
----

With these settings the hermetic bootstrap script is a no-op
(`scripts/bootstrap-trunk-python.sh`).

== Cache the CLI and results

Persist `~/.cache/trunk` so the CLI, plugins, and linters are reused between
runs.

GitHub Actions

[,yaml]
----
- uses: actions/cache@v4 with: path: ~/.cache/trunk key: ${{ runner.os
 }}-trunk-${{ hashFiles('**/.trunk/trunk.yaml') }} restore-keys: | ${{ runner.os
 }}-trunk-
----

GitLab ci

[,yaml]
----
cache: key: "trunk-${CI_RUNNER_EXECUTABLE_ARCH}" paths:
 - $HOME/.cache/trunk
----

== Command shape

* Pull requests: `trunk check --ci`
* Nightly/cron: `trunk check --all --ci`
The hold-the-line behaviour cuts runtime dramatically by touching only modified
files on PRs.

== Environment variables

Trunk doesn't inherit the shell environment. If you need proxies or locales,
define them in `.trunk/trunk.yaml`:

[,yaml]
----
lint: definitions:
 - name: eslint
environment:
 - name: HTTP_PROXY
value: ${HTTP_PROXY}
 - name: HTTPS_PROXY
 value: ${HTTPS_PROXY}
----

== When to consider alternatives

* *pre-commit* + *pre-commit.ci* -- No local downloads, strong community support,
 integrates with git hooks.
* *Mega-Linter* -- Containerized linter suite, good for locked-down environments,
 heavier on ci minutes.
Stick with Trunk if you can cache `~/.cache/trunk` and provide system runtimes;
swap only if network policies forbid the necessary downloads.
