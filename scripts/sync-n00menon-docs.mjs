#!/usr/bin/env node
/**
 * Keep the n00menon docs surfaces in sync:
 * - docs/index.md (source of truth)
 * - README.md (GitHub landing page)
 * - modules/ROOT/pages/index.adoc (Antora component)
 *
 * Usage:
 *   node scripts/sync-n00menon-docs.mjs --write   # default; updates files
 *   node scripts/sync-n00menon-docs.mjs --check   # exits 1 if sync drift is found
 */

import fs from "node:fs";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const args = new Set(process.argv.slice(2));
const checkMode = args.has("--check");
const writeMode = args.has("--write") || !checkMode;
const verbose = args.has("--verbose");

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(__dirname, "..");
const componentRoot = path.join(repoRoot, "n00menon");
const sourcePath = path.join(componentRoot, "docs", "index.md");
const readmePath = path.join(componentRoot, "README.md");
const antoraPath = path.join(componentRoot, "modules", "ROOT", "pages", "index.adoc");

function ensureFileExists(p) {
  if (!fs.existsSync(p)) {
    throw new Error(`Required file missing: ${p}`);
  }
}

function normalize(content) {
  return `${content.trimEnd()}\n`;
}

function convertMarkdownToAsciiDoc(markdown) {
  const lines = markdown.split("\n");
  const out = [];
  let inCode = false;
  let fenceLang = "text";

  for (const line of lines) {
    if (line.startsWith("```") && !inCode) {
      fenceLang = line.replace(/```+\s*/, "").trim() || "text";
      out.push(`[source,${fenceLang}]`);
      out.push("----");
      inCode = true;
      continue;
    }
    if (line.startsWith("```") && inCode) {
      out.push("----");
      inCode = false;
      continue;
    }
    if (inCode) {
      out.push(line);
      continue;
    }

    let converted = line;
    if (converted.startsWith("### ")) converted = `=== ${converted.slice(4)}`;
    else if (converted.startsWith("## ")) converted = `== ${converted.slice(3)}`;
    else if (converted.startsWith("# ")) converted = `= ${converted.slice(2)}`;

    if (converted.startsWith("- ")) converted = `* ${converted.slice(2)}`;

    converted = converted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, "link:$2[$1]");
    converted = converted.replace(/`([^`]+)`/g, "+$1+");

    out.push(converted);
  }

  if (inCode) {
    throw new Error("Unclosed fenced code block in docs/index.md");
  }

  return normalize(out.join("\n"));
}

function buildReadme(markdown) {
  const banner = "<!-- Synced from docs/index.md via scripts/sync-n00menon-docs.mjs. Edit the source and rerun docs:sync. -->\n\n";
  const body = markdown.replace(/^#\s+n00menon Docs/m, "# n00menon");
  return normalize(`${banner}${body}`);
}

function writeIfChanged(targetPath, nextContent, changes) {
  ensureFileExists(path.dirname(targetPath));
  const current = fs.existsSync(targetPath)
    ? fs.readFileSync(targetPath, "utf8")
    : "";
  if (current !== nextContent) {
    if (writeMode) {
      fs.writeFileSync(targetPath, nextContent, "utf8");
    }
    changes.push(targetPath);
  }
}

function main() {
  ensureFileExists(sourcePath);
  const markdown = normalize(fs.readFileSync(sourcePath, "utf8"));

  const readme = buildReadme(markdown);
  const adoc = normalize(
    `// Generated from docs/index.md via scripts/sync-n00menon-docs.mjs.\n// Do not edit this file directly.\n\n${convertMarkdownToAsciiDoc(markdown)}`,
  );

  const changed = [];
  writeIfChanged(readmePath, readme, changed);
  writeIfChanged(antoraPath, adoc, changed);

  if (changed.length === 0) {
    if (verbose) console.log("n00menon docs are already in sync.");
    return;
  }

  const prettyList = changed.map((p) => ` - ${path.relative(repoRoot, p)}`).join("\n");

  if (writeMode) {
    console.log(`Updated synced docs:\n${prettyList}`);
  } else {
    console.error(
      `n00menon docs are out of sync. Run pnpm run docs:sync-n00menon to update:\n${prettyList}`,
    );
    process.exit(1);
  }
}

main();
